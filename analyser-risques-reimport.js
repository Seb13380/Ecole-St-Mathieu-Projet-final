const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function analyserRisquesReimport() {
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('  ANALYSE DES RISQUES DE R√â-IMPORT EXCEL');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

    try {
        // 1. COMPTER LES DONN√âES ACTUELLES
        console.log('üìä √âTAT ACTUEL DE LA BASE DE DONN√âES');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

        const totalUsers = await prisma.user.count();
        const totalParents = await prisma.user.count({ where: { role: 'PARENT' } });
        const totalStudents = await prisma.student.count();
        const totalRelations = await prisma.parentStudent.count();

        console.log(`Total utilisateurs: ${totalUsers}`);
        console.log(`Total parents: ${totalParents}`);
        console.log(`Total √©l√®ves: ${totalStudents}`);
        console.log(`Total relations parent-√©l√®ve: ${totalRelations}`);

        // 2. IDENTIFIER LES PARENTS SANS ENFANTS
        console.log('\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ PARENTS SANS ENFANTS (√† risque de doublon)');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

        const parentsWithoutChildren = await prisma.user.findMany({
            where: {
                role: 'PARENT',
                enfants: { none: {} }
            },
            select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true,
                createdAt: true
            },
            orderBy: { createdAt: 'desc' }
        });

        console.log(`Nombre: ${parentsWithoutChildren.length}\n`);

        // Cat√©goriser les parents sans enfants
        const parentsWithTempEmail = parentsWithoutChildren.filter(p =>
            p.email.includes('temp_') || p.email.includes('@temporary.local')
        );

        const parentsWithRealEmail = parentsWithoutChildren.filter(p =>
            !p.email.includes('temp_') && !p.email.includes('@temporary.local')
        );

        console.log(`‚îî‚îÄ Avec email temporaire: ${parentsWithTempEmail.length} (FAIBLE RISQUE)`);
        console.log(`‚îî‚îÄ Avec email r√©el: ${parentsWithRealEmail.length} (RISQUE MOYEN)\n`);

        // 3. IDENTIFIER LES √âL√àVES SANS PARENTS
        console.log('üë∂ √âL√àVES SANS PARENTS (orphelins √† connecter)');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

        const studentsWithoutParents = await prisma.student.findMany({
            where: {
                parents: { none: {} }
            },
            select: {
                id: true,
                firstName: true,
                lastName: true,
                dateNaissance: true
            }
        });

        console.log(`Nombre: ${studentsWithoutParents.length}\n`);

        // 4. V√âRIFIER LES EMAILS EN DOUBLE
        console.log('üìß ANALYSE DES EMAILS');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');

        const allEmails = await prisma.user.findMany({
            where: { role: 'PARENT' },
            select: { email: true }
        });

        const emailCounts = {};
        allEmails.forEach(({ email }) => {
            emailCounts[email] = (emailCounts[email] || 0) + 1;
        });

        const duplicateEmails = Object.entries(emailCounts)
            .filter(([email, count]) => count > 1 && !email.includes('temp_'))
            .map(([email]) => email);

        console.log(`Emails en double (hors temp): ${duplicateEmails.length}`);
        if (duplicateEmails.length > 0) {
            console.log('Emails concern√©s:');
            duplicateEmails.slice(0, 5).forEach(email => console.log(`  - ${email}`));
            if (duplicateEmails.length > 5) {
                console.log(`  ... et ${duplicateEmails.length - 5} autres`);
            }
        }

        // 5. COMPORTEMENT DE L'IMPORT EXCEL
        console.log('\n‚öôÔ∏è COMPORTEMENT DE L\'IMPORT EXCEL');
        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
        console.log('‚úÖ L\'import v√©rifie les doublons AVANT de cr√©er:');
        console.log('   1. Parents: cherche par EMAIL puis par NOM+PR√âNOM');
        console.log('   2. √âl√®ves: cherche par NOM+PR√âNOM+DATE_NAISSANCE');
        console.log('   3. Relations: v√©rifie si d√©j√† existante');
        console.log('');
        console.log('‚úÖ Si un parent/√©l√®ve existe: R√âUTILISE l\'existant');
        console.log('‚úÖ Si une relation existe: NE CR√âE PAS de doublon');

        // 6. √âVALUATION DES RISQUES
        console.log('\n‚ö†Ô∏è √âVALUATION DES RISQUES');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

        const risques = [];

        // Risque 1: Parents avec email r√©el sans enfants
        if (parentsWithRealEmail.length > 0) {
            risques.push({
                niveau: 'MOYEN',
                description: `${parentsWithRealEmail.length} parents avec email r√©el sans enfants`,
                detail: 'Si leurs noms sont dans l\'Excel, leurs enfants seront associ√©s ‚úÖ',
                action: 'Pas de doublon car recherche par email'
            });
        }

        // Risque 2: Parents avec email temporaire
        if (parentsWithTempEmail.length > 0) {
            risques.push({
                niveau: 'FAIBLE',
                description: `${parentsWithTempEmail.length} parents avec email temporaire`,
                detail: 'Seront recherch√©s par NOM+PR√âNOM',
                action: 'Risque de doublon SI nom/pr√©nom diff√©rent dans Excel'
            });
        }

        // Risque 3: √âl√®ves orphelins
        if (studentsWithoutParents.length > 0) {
            risques.push({
                niveau: 'AUCUN',
                description: `${studentsWithoutParents.length} √©l√®ves sans parents`,
                detail: 'Seront associ√©s si pr√©sents dans Excel',
                action: 'Aucun risque - relations seront cr√©√©es'
            });
        }

        // Risque 4: Emails en double
        if (duplicateEmails.length > 0) {
            risques.push({
                niveau: '√âLEV√â',
                description: `${duplicateEmails.length} emails en double dans la base`,
                detail: 'L\'import prendra le premier trouv√©',
                action: '‚ö†Ô∏è NETTOYER LES DOUBLONS AVANT import'
            });
        }

        // Risque 5: Donn√©es non pr√©sentes dans Excel
        risques.push({
            niveau: 'MOYEN',
            description: 'Donn√©es absentes de l\'Excel',
            detail: 'Parents/√©l√®ves NON dans Excel ne seront PAS touch√©s',
            action: 'V√©rifier que votre Excel est COMPLET'
        });

        // Afficher les risques
        risques.forEach((risque, index) => {
            const emoji = {
                'AUCUN': '‚úÖ',
                'FAIBLE': '‚ö°',
                'MOYEN': '‚ö†Ô∏è',
                '√âLEV√â': 'üö®'
            }[risque.niveau];

            console.log(`\n${emoji} RISQUE ${risque.niveau}: ${risque.description}`);
            console.log(`   ${risque.detail}`);
            console.log(`   üëâ ${risque.action}`);
        });

        // 7. RECOMMANDATION FINALE
        console.log('\n');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('  RECOMMANDATION FINALE');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

        const risqueMax = risques.reduce((max, r) => {
            const niveaux = { 'AUCUN': 0, 'FAIBLE': 1, 'MOYEN': 2, '√âLEV√â': 3 };
            return niveaux[r.niveau] > niveaux[max.niveau] ? r : max;
        }, risques[0]);

        if (risqueMax.niveau === '√âLEV√â') {
            console.log('\nüö® ATTENTION: Risques √©lev√©s d√©tect√©s');
            console.log('   Recommandation: NETTOYER les doublons avant import\n');
            console.log('   √âtapes sugg√©r√©es:');
            console.log('   1. Ex√©cuter: node nettoyer-doublons-emails.js');
            console.log('   2. V√©rifier les r√©sultats');
            console.log('   3. Puis faire l\'import Excel');
        } else if (risqueMax.niveau === 'MOYEN' || risqueMax.niveau === 'FAIBLE') {
            console.log('\n‚úÖ Import Excel S√âCURIS√â');
            console.log('   Le syst√®me de d√©tection de doublons prot√©gera vos donn√©es\n');
            console.log('   Ce qui va se passer:');
            console.log('   ‚úÖ Parents existants ‚Üí R√©utilis√©s (pas de doublon)');
            console.log('   ‚úÖ √âl√®ves existants ‚Üí R√©utilis√©s (pas de doublon)');
            console.log('   ‚úÖ Relations manquantes ‚Üí Cr√©√©es');
            console.log('   ‚úÖ Parents sans enfants ‚Üí Enfants associ√©s s\'ils sont dans Excel');
            console.log(`   ‚ö†Ô∏è  Parents NON dans Excel (${totalParents - parentsWithoutChildren.length}) ‚Üí Non touch√©s`);
        } else {
            console.log('\n‚ú® Aucun risque d√©tect√©');
            console.log('   Vous pouvez proc√©der √† l\'import en toute s√©curit√©');
        }

        console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

        return {
            totalParents,
            totalStudents,
            totalRelations,
            parentsWithoutChildren: parentsWithoutChildren.length,
            studentsWithoutParents: studentsWithoutParents.length,
            duplicateEmails: duplicateEmails.length,
            risqueMaximal: risqueMax.niveau,
            securite: risqueMax.niveau !== '√âLEV√â'
        };

    } catch (error) {
        console.error('‚ùå ERREUR:', error.message);
        throw error;
    } finally {
        await prisma.$disconnect();
    }
}

// Ex√©cution
analyserRisquesReimport()
    .then(results => {
        if (results.securite) {
            console.log('‚úÖ Analyse termin√©e - Import Excel S√âCURIS√â');
            process.exit(0);
        } else {
            console.log('‚ö†Ô∏è  Analyse termin√©e - Actions recommand√©es avant import');
            process.exit(1);
        }
    })
    .catch(error => {
        console.error('‚ùå √âchec de l\'analyse:', error.message);
        process.exit(1);
    });
